  ### 로그인, 인증과 인가

  **로그인 인증 여부를 확인하기 위한 것**과 + **로그인 세션 유지는 어떻게 할것인가** → 두개로 분리하여 생각할것

    - **로그인 인증 여부**

      > Credential 을 통해 로그인을 하는 방식 + 로그인 된 유저 정보를 가져오는 방식 (전체/선택)
      >
        - **Authentication 인증, SSO** : Credential 을 통해 **유저 로그인 완료** (유저 정보 모두 취득 가능)
            - Credential 은 일반적으로 ID/PW 조합
            - **MFA (Multi-Factor Authentication)** : 핸드폰 추가 인증으로 Credential 탈취 대응 / 보완

            <aside>
            🔑 **Authentication 인증**

          ### **SSO (Single Sign-On)**

            - **Authentication 인증** : Credential (ID/PW) 입력하여 **(1) 로그인 완료** 및
                - **(2) 모든 필요 유저 정보 조회**

            ---

          ### 왜, SSO 가 필요한가?

            - **기존 : 아 서비스당 계정 만들기 귀찮아, 싫다**
                - a 계정(인증) → A 서비스
                - b 계정(인증) → B 서비스
                - c 계정(인증) → C 서비스
            - **SSO : 하나의 계정으로 다른 서비스 다 쓰세요**
                - x 계정(인증) → A 서비스
                - x 계정(인증) → B 서비스
                - x 계정(인증) → C 서비스

          ### SSO 한줄요약 : 퀘스트 아이템

          *"이 연회장에 들어가려면, 왕족의 **인증서(x 계정)**를 가져오거라"*

            - **SSO** 는 **Authentication 인증**

          ### SSO 원리 이해를 위해 숙지해야할 용어 2개

            - A, B, C 서비스 = **Service Provider(SP)** eg. 연회장
            - 인증서(x 계정) 제공하는 서버 = **Identity Provider(IdP)** eg. 왕족

          ### SSO 원리 : 3 절차

              **[Single Sign-On (SSO) 설명](https://youtu.be/O1cRJWYF-g4?si=qoAzmtQCKApNK-K4) : 꼭, 영상을 보고 이해를 도울 것**
            
              **비유**

            - **SAR** (SAML Authentication Request)

              : 연회장에 들어오려면(SP) 왕족(IdP)에게 인증서 받아오시기바랍니다.

            - **SAML** (Security Assertion Markup Language)

              : 왕족(IdP)님, 연회장(SP)에 가려면 인증서(x 계정) 받아오랍니다.

            - **SAML 검증** : SAML 을 Public Key 로 복호화 및 검증

              : 문지기 왈 "솜씨가 대단하군(???) 들어가도록 하여라"


              **실제**

            - **SAR** (SAML Authentication Request) : **인증서 요청서**
            - **SAML** (Security Assertion Markup Language) : **인증서**
                - 비대칭키 Private / Public 로 암호화되어있음
            - **SAML 검증** : SAML 을 Public Key 로 복호화 및 검증

          ### SSO 상세 방법론

            - **SAML** : XML 사용
            - **OIDC** : JWT 사용

          ### 질문 : SSO 와 OAuth 둘의 관계성?

          **질문** : HTTP 기반의 OAuth 프로토콜, OAuth 기반의 OIDC 프로토콜

            - 그렇다면 OIDC 는 OAuth 보다 진보된 프로토콜이라고 할 수 있는데
                - OAuth 는 인증 + 인가를 지원하고
                - OIDC 는 인가만 지원한다는것은 이해가 되지 않는다.

          **답변**

            - OAuth 는 **(1) 인증** 후 **(2) 인가를 통해 유저 데이터를 선택적으로 가져오나**
                - (1) 인증 시 Authorization Token 발행 ⇒ **Payload 가 단순**
                    - **= 구식의 프로토콜**
            - OIDC 는 **(1) 인증과 함께 유저 데이터를 한번에 다 가져오게된다.**
                - (1) 인증 시 Authorization Token + Resources 반환 ⇒ **Payload 가 고도화**
                    - **= 진보된 프로토콜**

         ![Untitled (5)](https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/69df436c-71d1-4cca-9c58-2730b02c3f1c)


            </aside>

        - **Authorization 인가, OAuth** : Credential 을 통해 **유저 로그인 후** **선택적 유저 정보 취득**
            - **Authentication 인증**이 선행되어야하기에, **Authentication 인증**으로 사용되기도 함
            - 그것이 꼭 잘못 사용하는것이라 할수있는가? 그렇게 보진 않는다.
                - **Authentication 인증**은 유저의 선택과 상관없이 **모든 유저 정보를 반환**한다.
                - **Authorization 인가**은 유저의 선택에 따라 **유저 정보를 선택적으로 반환**한다.
                    - 왜 OIDC 가 성능이 좋고, 더 보완된 프로토콜임에도 OAuth 가 사실상 표준인가?
                        - 유저 정보 취득 및 활용에 있어서 제어권을 유저에게 준 것
                        - 유저 정보 취득에서의 법적책임의 회피 목적이 있을수도 있겠다.

            <aside>
            🔑 **Authentication 인증 + Authorization 인가** (인가에는 인증이 항상 선행되어야하므로)

          ### OAuth

            - **Authentication 인증** : Credential (ID/PW) 입력하여 **(1) 로그인 완료**
            - **Authorization 인가** : **(2) 유저가 선택한 유저 정보만을 조회**

            ---

          ### OAuth 원리 이해를 위해 숙지해야할 용어

            - **Resource Owner**
            - Client (우리가 쓰려는 서비스)
            - **Authorization Server**
                - Consent Screen + Scopes
                1. **Authrozation Token** 발행
                2. **Authrozation Token → Access Token** 으로 바꾸어줌
            - **Resource Server**
                - **Access Token → Resource** 반환

          ### OAuth 원리

              **[OAuth 2.0 and OIDC 설명](https://youtu.be/996OiexHze0?si=NS_QQoLJqE8Odgit) : 꼭, 영상을 보고 이해를 도울 것**

         ![Untitled (6)](https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/4cadbc0c-49f4-48a1-a1a4-3d0b16d7894b)

            </aside>

    - **로그인 세션 유지 / 저장**

      > 로그인 인증 완료 및 로그인 된 유저 정보를 가져온것들을, **이 정보들을 어디 저장할것인가?**
      >
        - **Cookie (Browser Side) : Stateful**
            - 유저 정보값을 그대로 HTTP Cookie 로 설정하는 방식
            - **단점** : HTTP 요청 시 매번 헤더에 포함되기에, **보안에 취약 + 요청 시 네트워크 부하 심각**
            - 예) 앞선 로그인 인증 완료 후 유저 ID 와 유저 메일등을 Cookie 에 그대로 저장하는 방식
                - **오 신이시여, 정신나간 방식.**
                - 설명을 위해 넣은것일뿐 Cookie 에 유저 정보를 넣진않음
        - **Session (Server Side) : Stateful**
            - 서버측에서 별개의 세션 스토리지를 활용하여 저장
            - **단점** : 매번 로그인 완료 여부를 세션 스토리지 조회로 알아야하기에
                - 매 API 혹은 유저 접근 시 **시간 단축**을 위해, Redis 와 같은 비싼 메모리 기반 DB 활용
                - 서비스 유저가 늘어남에 따라 서버도 늘어나야하지만, 그에 맞춰 **세션 스토리지도 증가 필요**
                    - 확장성 문제, Horizontal Scaling
            - **질문** : 어자피 SessionID 는 Cookie 에 저장해야하는거 아닌가요? 이게 탈취된다면?
                - 어떤 개발자가 네이버에서 단순 SESSIONID 탈취로 해킹을 시도했으나 인증이 안됐다고함
                    - 접속한 기기라던가 IP 등 기타 정보들을 취합하는것으로 보임. 신기했다.
        - **JWT (Client Side Storage, 웹이라면 Cookie 앱이라면 자체 저장소에 저장) : Stateless**
            - JWT 방식은 웹 서비스에서 쓴다면 사실상 Cookie 와 같음
                - 하지만 **앱**과 같이 HTTP Cookie 를 가진 **웹**이 아닌 것이라면 자체 저장소 사용
            - **질문** : HTTP Cookie 는 Stateful 이라며 왜 JWT 는 Stateless 인가?
                - JWT 이 **웹** 서비스에서 사용되면 Cookie 기에 Domain + Path 기반 **Stateful**
                - JWT 이 **앱** 서비스에서 사용되면 자체 저장소에 저장하기에 **Stateless**
                    - **결론** : JWT 는 상황에 따라 달리 해석될 케이스는 존재하나 **Stateless** 이다.
                        - **이유** : JWT 가 탈취되면 사용자가 누군지에 상관없이 원하는 결과를 얻을수있음
            - Header, Payload 가 BASE64 로 인코딩되어있어 누구든지 바로 읽어낼 수 있다.
            - 데이터 위변조가 가능하지만, Signature 를 통해 위변조 여부를 판단할 수는 있다.
            - **JWT 상세 구성 및 동작 원리 ([출처](https://inpa.tistory.com/559))**

              ![Untitled (7)](https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/ae8684eb-e80f-4164-bfe5-ebe753711405)


                - **Header** : 아래 Signature 가 어떤 알고리즘으로 암호화되었나 (서버가 자체키로 복호화)
                    - **BASE64** = 바로 정보 읽어낼 수 있음
                        - 애초에 BASE64 는 인코딩이지, 암호화 방식이 아니기 때문

                  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/cd689693-149b-44c4-a203-a4bc60086f78/4db35fcc-bab5-4c0b-9963-96d35180762c/Untitled.png)

                - **Payload** : 서버가 실제로 사용할 데이터를 적재
                    - **BASE64** = 바로 정보 읽어낼 수 있음
                        - 애초에 BASE64 는 인코딩이지, 암호화 방식이 아니기 때문
                        - **특히 Payload 의 경우 조심해야하는게, 여기에 민감정보를 담으면 그대로 노출**
                            - **어떠한 노력도 없이, 바보처럼 BASE64 로 디코딩해서 만천하에 노출하는격**
                            - **정말 필요한 최소한의 정보만 넣자**
                    - 위 예시에는 **발생시간(iat)** 만 있지만, 만료시간(exp)이

                  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/cd689693-149b-44c4-a203-a4bc60086f78/5a16d49d-c92d-4a64-9907-38ff36cd6ce9/Untitled.png)

                - **Signature** : 해시가 단방향 암호화라 복호화가 아닌 **Header**, **Payload** 변조 여부만 판단
                    - **HMAC**SHA256 = 노출되어있어도 HMAC Key 는 서버만알고, 복호화 애당초 불가
                        - **BASE64** 로 인코딩된 위 **Header**, **Payload** 와 달리 암호화되었음
                        - **HASH** 란 많거나 큰 정보를 ⇒ 작은 단위의 정보로 치환하는것
                            - 단방향 암호화이기 때문에 한번 HASH 값을 구하면 역산이 불가능
                    - **질문** : 블로그 글 중 JWT 와 Session 차이가 속도라고 되어있는데 어떤 의미인지?
                        - **답변** : 로그인 여부를 판단하기 위해 Session 은 DB 를 조회해야하는데
                            - DB 조회라는건 네트워크를 통해 가져온다는 뜻이기도하고, 트랜잭션 등
                                - 여러 객체들을 사용해야되어서, JWT 에 비해 느린것은 사실
                            - JWT 사용 시 서버에서 복호화없이, 그냥 변조여부만 판단 후 바로씀
                            - **변조여부만 판단한다** (빠름) **>** **매번 DB 를 조회** (느림)
                                - **하지만, 단순히 빠르다고 JWT 를 써야한다는것은 아님**
            - **단점** : 로그인 세션 데이터를 브라우저가 갖고 있기때문에 **실시간성을 보장할 수 없다.**
                - **방금전에 Aaron 에서 Baron 으로 개명해도 JWT 내 유저 정보 상엔 Aaron 이라는 이름**
                - **JWT 가 탈취가 되었을 시, JWT 를 통해 인증이 필요한 작업을 타인이 수행가능한 문제**
                    - 이를 보완하기 위해 Refresh Token 을 통해 Access Token 의 만료
                        - Access Token 의 만료기간을 10분으로 설정
                        - Access Token 이 탈취된다해도, 10분이 지나면 Refresh Token 로 갱신필요
                            - 탈취된 Access Token 는 10분만 지나면 활용할 수 없게됨
                            - **이 주기를 짧게하면 Refresh 비용이 증가하고, 길게하면 탈취대응이 힘듬**

      ![Untitled (7)](https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/b6daa42c-6ba4-421c-9c90-6107da790d88)

        - **결과적으로 현업에서 로그인 세션 유지 / 저장에 어떤 방식을 가장 많이 사용하는가?**
            - = **Session (Server Side)**
            - 이유 : 과연 **확장성 문제**가 작은 스타트업에게 문제가 될까? 반문해볼만하다.
                - JWT 에 민감 정보를 넣지 못하기에

  ### Next-Auth 동작 원리

 <img width="1024" alt="Untitled (10)" src="https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/189e76d9-57c4-4fca-af5a-f727e153e33c">


  ### AWS 클라우드 기초

  **위대한 시작 ([제프 베조스는 왜 AWS 를 만들었을까?](https://youtu.be/uSkkBKTHIog?si=xQfr_pBh7_jAJnqd))**

    - 2002년 아마존 서비스 내부 사용 - 책을 팔던 회사에서 서버 가상화가 필요했었음
    - 2003년 다른 회사에게 논리 서버의 외주화 - **물리 서버**를 대체하는 **가상 서버**를 판매해볼까
    - 2006년 EC2 + S3 + SQS 런칭

  **AWS 클라우드란 무엇인가?**

    - 물리 서버가 아닌 **가상 서버 대여**
        - 가상 서버들을 우리가 직접 원하는 대로 구성할 수 있고(**VPC 및 네트워크**)
        - 가상 서버의 종류도 점차 늘어나서 다양한 가상 서버를 제공
            - 단순한 컴퓨터(**EC2**)에서 데이터베이스(**RDS**)로 그리고 정적 컨텐츠 저장소(**S3**)
            - DNS(**Route53**) 설정도 가능하고, CDN(**CloudFront**) 및 서버리스(**Lambda**)도 지원…
    - **사실상 서비스를 만들기 위한 모든 클라우드를 AWS 가 제공 = 단군이래 SaaS 창업하기 가장 쉬운 시대**

  **클라우드에서 짚고 넘어가야할 단어 ([이미지 출처](https://www.whatap.io/ko/blog/9/), [RedHat 공식 문서](https://www.redhat.com/en/topics/cloud-computing/iaas-vs-paas-vs-saas))**

 ![Untitled (11)](https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/12b50bec-ccac-49d2-9fe5-74f90d69bfb0)


    - **IaaS** (Infrastructure as a Service) : 서버 및 네트워크 기초 구성은 이미 완료, **OS 선택부터 시작**
    - **PaaS** (Platform as a Service) : OS 및 서버에 필요한 배포 요소들 준비, **원하는 서비스만 올리면 됨**
    - **SaaS** (Software as a Service) : 서버, 네트워크, 가용성, 서비스 모두 이미 다 개발되어
        - **서비스만 사용하면되는 상태**
            - 예를 들면 **Slack(슬랙)** 과 같은 **비설치형 프로그램** 은 **클라우드로 모두 제공**

  **AWS 클라우드 서비스는 어떻게 제공되는가?**

  > 클라우드(가상)로 제공되지만, 실제로는 물리 서버들을 모두 연결하여 그걸 가상화하여 클라우드로 제공
  >
    - 서비스 타입이 2개로 나뉘어져 있다 : **글로벌 서비스 / 리전 서비스**
        - **리전 서비스** : 리전에 국한되어(Region-scoped) 제공되는 서비스들
            - EC2 : 서버 (Infrastructure as a Service)
            - Elastic Beanstalk : 서비스 배포 및 제공 (Platform as a Service)
            - Lambda : 서버리스 함수 실행기, 등
        - **글로벌 서비스** : 리전에 상관없이 전역적으로 제공되어야하는 서비스들, 예를 들어 DNS
            - IAM : AWS 계정 권한 및 역할 관리
            - Route53 : DNS Service
            - CloudFront : CDN
            - WAF : Web Application Firewall
            - Certificate Manager : HTTPS 등 관리, 등
    - **Region** : 전 세계에 존재한다 (국가 차원으로 생각하면된다) **← 리전 서비스**
        - **물리적으로**, **AZ (Available Zone)** 의 집합
            - **AZ (Available Zone)** 는 지역별로 설치되어있는 **Data Center** 의 집합
                - **Region** : 시드니 리전 (ap-southeast-2)
                - **AZ (Available Zone)** : 시드니 리전은 3개 AZ 로 구성
                    - ap-southeast-2a/2a/2c
                - **Data Center** : 각 AZ 는 2개의 Data Center 로 구성

             <img width="420" alt="Untitled (12)" src="https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/2bf0d6d0-49bc-4aa0-ae8e-8f0dc5590ccd">


        - 대부분의 AWS 서비스들은 특정 리전에 연결되어 국한된다 (Region-scoped)
            - AWS 클라우드를 활용해서 서비스를 제공하고싶을때 무엇을 기준으로 선택할까?
                - **Proximity** : 근접성 (시간 지연)
                - **Available Service** : 특정 AWS 서비스는 특정 리전에서만 지원
        - **예시 이미지** - 예) 한국 리전, 일본 리전, 북미 리전 (us-east-1, eu-west-3, …) 등

          <img width="239" alt="Untitled (13)" src="https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/c4695e02-fb37-4436-8a65-c99f510f6e64">

    - **Edge Locations (CDN, Lambda)** **← 글로벌 서비스**

  **AWS 클라우드 자원들은 어떻게 관리될 수 있는가? 고유 아이디?**

    - ARN (AWS Resource Name)

  ### 네트워크 개요

  **CIDR** : 2개로 구성된다 = **Base IP** + **Subnet Mask**

  > **CIDR** 는 어떤 의미를 갖는가? 우리가 사용 가능한 **IP Range
    - 쉽게 풀어서 설명** = 10.0.0.0 에서 10.0.0.255 까지 사용 가능합니다
    - **위 설명을 CIDR 로 간단히 표현하면** = 10.0.0.0/24

  왜 이렇게 표현하는가? 있어보이려고하는건가?
  : **심플하니까**
  >
  - **Base IP** = **사용 가능한 첫 IP**
  - **Subnet Mask** = 위 Base IP 에서 **미사용 영역**
  - Masking Tape 마스킹테이프 : 페인트 칠같은것을 할때 묻지말아야할 영역을 막기 위한 테이프
  - **Masking 마스킹 = 가리는 영역 = 미사용 영역**

  > CIDR 는 언제 사용하나요? = **네트워크를 정의할때

    1. VPC 나 물리적 서버실 내 네트워크를 정의할때** = 내가 총 몇개의 서버를 사용할것인지
       **2. Subnet(서브넷) : 서브 네트워크를 정의할때** = VPC 나 물리적 서버실 내 서버의 영역들을 나눌때
  >
    - 연습 문제
        - 192.168.0.0/24 ⇒ IP Range 는 어디서 어디까지? 몇개?
        - 192.168.0.0/16 ⇒ IP Range 는 어디서 어디까지? 몇개?
        - 134.56.78.123/32 ⇒ IP Range 는 어디서 어디까지? 몇개?
        - 0.0.0.0/0 ⇒ IP Range 는 어디서 어디까지? 몇개?

  **OSI 7 Layer**
    
  > 이걸 왜 배우나요?
  : 어쨌든 웹은 데이터의 주고받음. 네트워크는 그냥 택배라고 생각하면된다.
  경기도 고양시 일산동구 X A동 B호 로 택배를 보내기 위해서는
  **A 허브** : 경기도 B 허브로 전달 → **B 허브** : 고양시 C 허브로 전달 → **C 허브** : 일산동구 D 허브로 전달
  - 각 허브에서 다음의 허브로 전달 시 사용하는 값. 즉, **관심사**가 다르다

    - **L3 네트워크 장비**는 IP 주소를 보고 다음 전달지를 결정한다
    - **L2 네트워크 장비**는 MAC 주소를 보고 다음 전달지를 결정한다
    - **L1 네트워크 장비**는 단순히 신호(Signal)을 전달한다
  >
  >
  > <img width="946" alt="Untitled (14)" src="https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/76d77305-9b89-40b8-a0a9-9c5969cc971e">

  >
  > (출처 : https://youtu.be/0y6FtKsg6J4?si=hMCcrwKCw5nQIIlG)
  >
  > ![Untitled (16)](https://github.com/TaskerJang/ASAC-3rd-Study/assets/124780552/965ec490-d19a-4218-bfcb-c453103a2e3f)

  >
  > (출처 : [https://ngwoon.github.io/network/2020/11/12/OSI-7계층/](https://ngwoon.github.io/network/2020/11/12/OSI-7%EA%B3%84%EC%B8%B5/))
  >

  중요한 레이어는 아래 5개만 알면된다

    - **7 Application** Layer 응용 계층 : 관심사 = **HTTP Header + Method + IP + Port**
        - **HTTP**, WS: WebSocket (HTTP 기반), SMTP, OAuth (HTTP 기반), OIDC (HTTP 기반)
            - 여기서 Application 은 WAS Application 과 비슷한 느낌이지만 동일한 의미로 쓰인건 아님
    - **4 Transport** Layer 트랜스포트 계층 : 관심사 = **IP + Port**
        - **TCP** - 신뢰성, **UDP** - 비신뢰성
            - **TCP** - 자 이걸 줄게, 잘 받았어? (상냥) ⇒ 일반적인 서비스
            - **UDP** - 옛다 이거나 받아라! (츤츤) ⇒ 유튜브같은 영상 서비스
                - 몇개의 Packet Loss 가 발생해도 영상은 계속 재생되야함
    - **3 Network** Layer 네트워크 계층 : 관심사 = **IP**
    - **2 Data Link** Layer 데이터링크 계층 : 관심사 = **MAC 주소**
    - 1 Physical Layer 물리 계층

  ### 네트워크 장비

  OSI 7 Layer 에 대한 이해가 있다면, 네트워크 장비에 대한 이해가 쉽다.

  > 왜 네트워크 장비를 배우는가? AWS 네트워크 세부 설정이 네트워크 장비와 거의 다름없다.
  >
    - Switch (L2 Switch) : **MAC 주소** 기반 전달
    - Router (L3 Switch) : **IP** 기반 전달
    - L4 Load Balencer (L4 Switch) : **IP + Port** 기반 전달
    - L7 Load Balencer (L7 Switch) : HTTP 페이로드 (**HTTP Header + Method + IP + Port**) 기반

  ### AWS 네트워크 개요 : VPC 에서 시작하는 네트워크 구성

  ### AWS DNS : Route53

  ### AWS IAM : AWS 계정 및 자원에 대한 권한 관리
